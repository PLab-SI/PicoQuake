{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"acquisition_data/","title":"Acquisition CSV File","text":"<p>The CSV file contains IMU sample data from an acquisition session, along with relevant metadata about the PicoQuake device, acquisition configuration, and session details.</p>"},{"location":"acquisition_data/#metadata","title":"Metadata","text":"<p>The first few lines of the CSV file contain metadata about the acquisition session:</p> <pre><code># PLab PicoQuake Data\n# Time: 2024-04-21 15:54:46.333682, Device: C6E3 (E66368254F89A225), FW: 1.0.0\n# Num. samples: 10000, Duration: 5.0 s\n# Config: data_rate = 2000.0 Hz, filter = 488 Hz, acc_range = 4 g, gyro_range = 250.0 dps\n# Integrity: True, Skipped samples: 0\n</code></pre> <ul> <li><code>Time</code>: Acquisition start time (local timezone in ISO 8601 format).</li> <li><code>Device</code>: Device information, including the device short ID, unique ID and firmware version.</li> <li><code>Num. samples</code>: Number of samples collected during the acquisition session.</li> <li><code>Duration</code>: Duration of the acquisition session (in seconds).</li> <li><code>Config</code>: Acquisition configuration details, including data rate, filter frequency, accelerometer range, and gyroscope range.</li> <li><code>Integrity</code>: Integrity status of the acquisition (whether there are skipped samples).</li> <li><code>Skipped samples</code>: Number of skipped samples (if any) during the acquisition session.</li> </ul>"},{"location":"acquisition_data/#data-columns","title":"Data Columns","text":"<p>After the metadata, the CSV file contains the actual IMU sample data organized into columns. The columns are:</p> <ol> <li><code>count</code>: Sample count, representing the sequential number of each sample.</li> <li><code>a_x</code>: Acceleration in the X-axis (in g).</li> <li><code>a_y</code>: Acceleration in the Y-axis (in g).</li> <li><code>a_z</code>: Acceleration in the Z-axis (in g).</li> <li><code>g_x</code>: Gyro data in the X-axis (in degrees per second).</li> <li><code>g_y</code>: Gyro data in the Y-axis (in degrees per second).</li> <li><code>g_z</code>: Gyro data in the Z-axis (in degrees per second).</li> </ol> <p>1 g = 9.81 m/s\u00b2</p>"},{"location":"acquisition_data/#example-data","title":"Example Data","text":"count a_x a_y a_z g_x g_y g_z 1 0.96 0.41 0.53 19.71 123.73 93.19 2 0.72 0.51 0.53 14.60 105.12 77.13 3 0.77 0.51 0.37 19.36 199.39 145.63 4 0.11 0.84 0.34 246.19 245.97 77.86 5 0.07 0.96 -0.12 126.98 249.99 57.25"},{"location":"cli/","title":"CLI Reference","text":""},{"location":"cli/#usage","title":"Usage","text":"<pre><code>picoquake [-h] [-v] [--verbose] [--debug] {acquire,display,list,test,plot_psd,plot} ...\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"<ul> <li><code>-v</code>, <code>--version</code>: Show the version of the CLI.</li> <li><code>--debug</code>: Set log level to debug.</li> <li><code>--verbose</code>: Print log messages to console.</li> </ul>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#acquire","title":"acquire","text":"<p>Acquire data from a PicoQuake device.</p> <pre><code>picoquake acquire [-h] [-s SECONDS] [-r SAMPLE_RATE] [-f FILTER] [-ar ACC_RANGE] [-gr GYRO_RANGE] [-a] [-y] short_id out\n</code></pre> <ul> <li><code>short_id</code>: The 4 character ID of the device. Found on the label.</li> <li><code>out</code>: The output CSV file.</li> <li><code>-s</code>, <code>--seconds</code>: Duration of the acquisition in seconds (default: 2.0).</li> <li><code>-r</code>, <code>--sample_rate</code>: Sample rate in Hz. Range 12.5 - 4000 Hz. Closest available selected (default: 200.0).</li> <li><code>-f</code>, <code>--filter</code>: Filter frequency in Hz. Range 42 - 3979 Hz. Closest available selected (default: 42.0).</li> <li><code>-ar</code>, <code>--acc_range</code>: Acceleration range in g. Range 2 - 16 g. Closest available selected (default: 4.0).</li> <li><code>-gr</code>, <code>--gyro_range</code>: Gyro range in dps. Range 15.625 - 2000 dps. Closest available selected (default: 1000.0).</li> <li><code>-a</code>, <code>--autostart</code>: Start acquisition without user confirmation.</li> <li><code>-y</code>, <code>--yes</code>: Skip overwrite prompt.</li> </ul>"},{"location":"cli/#trigger","title":"trigger","text":"<p>Start acquisition at a RMS threshold trigger.</p> <pre><code>picoquake trigger [-h] [-r SAMPLE_RATE] [-f FILTER] [-ar ACC_RANGE]\n                       [-gr GYRO_RANGE] --rms_threshold RMS_THRESHOLD\n                       [--pre_seconds PRE_SECONDS] [--post_seconds POST_SECONDS]\n                       [--source {accel,gyro}] [-a AXIS] [--rms_window RMS_WINDOW]\n                       [-y] short_id out\n</code></pre> <ul> <li><code>short_id</code>: The 4 character ID of the device. Found on the label.</li> <li><code>out</code>: The output CSV file.</li> <li><code>-r</code>, <code>--sample_rate</code>: Sample rate in Hz. Range 12.5 - 4000 Hz. Closest available selected (default: 200.0).</li> <li><code>-f</code>, <code>--filter</code>: Filter frequency in Hz. Range 42 - 3979 Hz. Closest available selected (default: 42.0).</li> <li><code>-ar</code>, <code>--acc_range</code>: Acceleration range in g. Range 2 - 16 g. Closest available selected (default: 4.0).</li> <li><code>-gr</code>, <code>--gyro_range</code>: Gyro range in dps. Range 15.625 - 2000 dps. Closest available selected (default: 1000.0).</li> <li><code>--rms_threshold</code>: RMS threshold for triggering (required).</li> <li><code>--pre_seconds</code>: Duration before trigger in seconds (default: 0.0).</li> <li><code>--post_seconds</code>: Duration after trigger in seconds (default: 1.0).</li> <li><code>--source</code>: Source for triggering, must be 'accel' or 'gyro' (default: 'accel').</li> <li><code>-a</code>, <code>--axis</code>: Axis to plot, must be 'x', 'y', 'z', or a combination (default: 'xyz').</li> <li><code>--rms_window</code>: Window size for RMS calculation (default: 1.0).</li> <li><code>-y</code>, <code>--yes</code>: Skip overwrite prompt.</li> </ul>"},{"location":"cli/#run","title":"run","text":"<p>Run acquisition from a TOML configuration file. Supports advanced options like trigger and continuous acquisition.</p> <pre><code>picoquake run [-h] config\n</code></pre> <ul> <li><code>config</code>: TOML configuration file.</li> </ul> <p>Example configuration file:</p> <pre><code># Example configuration file for 'run' command\n# either [acquire] or [trigger] section is required\n\n[device]\nshort_id = \"C6E3\" # short id of the device\n\n[config]\nsample_rate = 1000 # sample rate in Hz. Range 12.5 - 4000 Hz. Closest available selected.\nfilter = 100 # filter frequency in Hz. Range 42 - 3979 Hz. Closest available selected.\nacc_range = 16 # acceleration range in g. Range 2 - 16 g. Closest available selected.\ngyro_range = 1000 # gyro range in dps. Range 15.625 - 2000 dps. Closest available selected.\n\n[acquire]\n# define duration in seconds or number of samples\nseconds = 3\n# n_samples = 10000\n\n# [trigger]\n# rms_threshold = 1.0 # RMS threshold for trigger\n# pre_seconds = 1 # duration before trigger\n# post_seconds = 2 # duration after trigger\n# source = \"accel\" # trigger source: \"accel\" or \"gyro\"\n# axis = \"xyz\" # trigger axis, must be 'x', 'y', 'z', or a combination\n# rms_window = 1.0 # window for RMS calculation in seconds\n\n[output]\npath = \"pq_acq.csv\" # output file path or directory if use_timestamp is true\nconfirm_overwrite = true # require confirmation before overwriting\nsequential = true # add sequence number to filename\nuse_timestamp = false # use timestamp as filename\n\n# [continuous] # continuous acquisition if this section is defined\n# interval = 0 # interval in seconds, 0 for continuous acquisition\n</code></pre>"},{"location":"cli/#display","title":"display","text":"<p>Display live data from a device.</p> <pre><code>picoquake display [-h] [-i INTERVAL] short_id\n</code></pre> <ul> <li><code>short_id</code>: The 4 character ID of the device. Found on the label.</li> <li><code>-i</code>, <code>--interval</code>: Interval between samples in seconds. Range 0.1 - 10 s (default: 1.0).</li> </ul>"},{"location":"cli/#list","title":"list","text":"<p>List connected PicoQuake devices.</p> <pre><code>picoquake list [-h] [-a]\n</code></pre> <ul> <li><code>-a</code>, <code>--all</code>: List all serial ports.</li> </ul>"},{"location":"cli/#info","title":"info","text":"<p>Display device information.</p> <pre><code>picoquake info [-h] short_id\n</code></pre> <ul> <li><code>short_id</code>: The 4 character ID of the device. Found on the label.</li> </ul>"},{"location":"cli/#test","title":"test","text":"<p>Test device.</p> <pre><code>picoquake test [-h] short_id\n</code></pre> <ul> <li><code>short_id</code>: The 4 character ID of the device. Found on the label.</li> </ul>"},{"location":"cli/#bootsel","title":"bootsel","text":"<p>Put device in BOOTSEL mode.</p> <pre><code>picoquake bootsel [-h] short_id\n</code></pre> <ul> <li><code>short_id</code>: The 4 character ID of the device. Found on the label.</li> </ul>"},{"location":"cli/#plot","title":"plot","text":"<p>Plot acquired acceleration data (time series).</p> <pre><code>picoquake plot [-h] [-a AXIS] [--tstart TSTART] [--tend TEND] [--title TITLE] [--rms] [--rms_detrend] [--rms_win RMS_WIN] csv_path output\n</code></pre> <ul> <li><code>csv_path</code>: The CSV file containing the acquired data.</li> <li><code>output</code>: The output file to save the plot to. '.' to save next to the data file.</li> <li><code>-a</code>, <code>--axis</code>: Axis to plot, must be 'x', 'y', 'z', or a combination (default: xyz).</li> <li><code>--tstart</code>: Start time of the plot (default: -inf).</li> <li><code>--tend</code>: End time of the plot (default: inf).</li> <li><code>--title</code>: Title of the plot (default: None).</li> <li><code>--rms</code>: Calculate and display RMS values.</li> <li><code>--rms_detrend</code>: Detrend the data before calculating RMS.</li> <li><code>--rms_win</code>: Window size for RMS calculation (default: 1.0 s).</li> </ul>"},{"location":"cli/#plot_psd","title":"plot_psd","text":"<p>Plot Power Spectral Density of acquired acceleration data.</p> <pre><code>picoquake plot_psd [-h] [-a AXIS] [--fmin FMIN] [--fmax FMAX] [--peaks] [--title TITLE] [--tstart TSTART] [--tend TEND] csv_path output\n</code></pre> <ul> <li><code>csv_path</code>: The CSV file containing the acquired data.</li> <li><code>output</code>: The output file to save the plot to. '.' to save next to the data file.</li> <li><code>-a</code>, <code>--axis</code>: Axis to plot, must be 'x', 'y', 'z', or a combination (default: xyz).</li> <li><code>--fmin</code>: Minimum frequency to plot (default: 0.0).</li> <li><code>--fmax</code>: Maximum frequency to plot (default: 1000.0).</li> <li><code>--peaks</code>: Annotate peaks on the plot.</li> <li><code>--title</code>: Title of the plot (default: None).</li> <li><code>--tstart</code>: Start time for analysis (default: -inf).</li> <li><code>--tend</code>: End time for analysis (default: inf).</li> </ul>"},{"location":"cli/#plot_fft","title":"plot_fft","text":"<p>Plot Fast Fourier Transform of acquired acceleration data.</p> <pre><code>picoquake plot_fft [-h] [-a AXIS] [--fmin FMIN] [--fmax FMAX] [--peaks] [--title TITLE] [--tstart TSTART] [--tend TEND] csv_path output\n</code></pre> <ul> <li><code>csv_path</code>: The CSV file containing the acquired data.</li> <li><code>output</code>: The output file to save the plot to. '.' to save next to the data file.</li> <li><code>-a</code>, <code>--axis</code>: Axis to plot, must be 'x', 'y', 'z', or a combination (default: xyz).</li> <li><code>--fmin</code>: Minimum frequency to plot (default: 0.0).</li> <li><code>--fmax</code>: Maximum frequency to plot (default: 1000.0).</li> <li><code>--peaks</code>: Annotate peaks on the plot.</li> <li><code>--title</code>: Title of the plot (default: None).</li> <li><code>--tstart</code>: Start time for analysis (default: -inf).</li> <li><code>--tend</code>: End time for analysis (default: inf).</li> </ul>"},{"location":"fw_update/","title":"Firmware update","text":""},{"location":"fw_update/#check-firmware-version","title":"Check firmware version","text":"<p>Check the current firmware version on you device by running:</p> <pre><code>picoquake info &lt;short_id&gt;\n</code></pre>"},{"location":"fw_update/#update-firmware","title":"Update firmware","text":"<p>To update the firmware on your device, follow these steps:</p> <ol> <li>Download the latest firmware (.uf2) from the releases page</li> <li>Put the device in BOOTSEL mode by running:     <pre><code>picoquake bootsel &lt;short_id&gt;\n</code></pre>     The device will appear as a removable drive named <code>RPI-RP2</code> on your computer.</li> <li>Flash the firmware:<ul> <li>Drag and drop the downloaded .uf2 firmware file to the <code>RPI-RP2</code> drive.</li> <li>Device will automatically reboot after the firmware is flashed.</li> </ul> </li> <li>Check if firmware updated correctly  by running:     <pre><code>picoquake info &lt;short_id&gt;\n</code></pre></li> </ol>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#requirements","title":"Requirements","text":"<p>A computer with:</p> <ul> <li>Windows, Linux or macOS</li> <li>Python 3.9 or higher</li> <li>pip</li> </ul>"},{"location":"getting_started/#install","title":"Install","text":""},{"location":"getting_started/#basic-installation","title":"Basic installation","text":"<p>Run command:</p> <pre><code>pip install picoquake\n</code></pre> <p>The recommended way to install if you don't need plotting capabilities. Only supports saving CSV data.</p>"},{"location":"getting_started/#plotting-capabilities","title":"Plotting capabilities","text":"<p>Run command:</p> <pre><code>pip install 'picoquake[plot]'\n</code></pre> <p>Enables creating diagrams in time and frequency domain. Additional dependencies will be installed:</p> <ul> <li>NumPy</li> <li>SciPy</li> <li>Matplotlib</li> </ul>"},{"location":"getting_started/#test-installation","title":"Test Installation","text":"<p>Run command:</p> <pre><code>picoquake --version\n</code></pre> <p>The above command should print the installed version of the package. If you see an error, try the alternative:</p> <pre><code>python -m picoquake --version\n</code></pre> <p>Note</p> <p><code>python -m</code> prefix is needed if the python scripts directory is not in the system PATH. It depends on your OS and the way Python was installed. Check the official Python documentation for more information.</p>"},{"location":"getting_started/#connect","title":"Connect","text":"<p>Connect PicoQuake to your computer. The green LED will light up.</p> <p>Run command:</p> <pre><code>picoquake --list\n</code></pre> <p>It will print a list of connected devices:</p> <pre><code>PicoQuake C6E3: /dev/cu.usbmodem1101\n...\n</code></pre> <p>No devices</p> <p>If you don't see any devices, check the connection and try again. You can also try another USB port.</p> <p>Short ID</p> <p>All further commands require a <code>Short ID</code> of the device. It's printed on the device label, or can be read by the <code>--list</code> command.</p>"},{"location":"getting_started/#test","title":"Test","text":"<p>Run command:</p> <pre><code>picoquake display c6e3\n</code></pre> <p>Orange LED will light up, and realtime data will be displayed in the terminal. Try to move the device to see the changes.</p>"},{"location":"getting_started/#whats-next","title":"What's next?","text":"<p>See Usage for detailed instructions. </p> <p>Run <code>picoquake --help</code> to see all available commands.</p>"},{"location":"plotting/","title":"Plotting","text":"<p>Note</p> <p>To enable plotting, <code>picoquake</code> must be installed with the <code>plot</code> extra. See Installation for more information.</p>"},{"location":"plotting/#plot-time-series-data","title":"Plot time series data","text":"<p>Plot time series data from a CSV file.</p> <p></p> <pre><code>picoquake plot &lt;csv_path&gt; &lt;output&gt;\n</code></pre> <p>You can specify the time range to plot using the <code>--tstart</code> and <code>--tend</code> arguments. The axes can be selected using the <code>-xyz</code> flag. Input only the desired axes in any order. This command plots only the acceleration data.</p> <p>For more information about the command, see CLI reference.</p>"},{"location":"plotting/#plot-power-spectral-density-psd","title":"Plot power spectral density (PSD)","text":"<p>Plot power spectral density (PSD) data from a CSV file.</p> <pre><code>picoquake plot_psd &lt;csv_path&gt; &lt;output&gt;\n</code></pre> <p></p> <p>You can specify the frequency range to plot using the <code>--fmin</code> and <code>--fmax</code> arguments. The axes can be selected using the <code>-xyz</code> flag. Input only the desired axes in any order. To annotate peaks, use the <code>--peaks</code> flag. This command processes only the acceleration data.</p> <p>For more information about the command, see CLI reference.</p> <p>Note</p> <p>PSD plot filters out the DC component of the signal.</p> Power spectral density (PSD) <p>Power Spectral Density (PSD) represents a signal's power distribution across different frequencies. It's commonly used to analyze broadband random signals. The PSD's amplitude is normalized based on the spectral resolution used during signal digitization.</p> <p>For vibration data, the PSD is measured in units of g\u00b2/Hz. This unit allows for the comparison and overlay of random data regardless of the spectral resolution used in measurement.</p>"},{"location":"plotting/#plot-fast-fourier-transform-fft","title":"Plot Fast Fourier Transform (FFT)","text":"<p>Plot Fast Fourier Transform (FFT) data from a CSV file.</p> <pre><code>picoquake plot_fft &lt;csv_path&gt; &lt;output&gt;\n</code></pre> <p></p> <p>You can specify the frequency range to plot using the <code>--fmin</code> and <code>--fmax</code> arguments. The axes can be selected using the <code>-xyz</code> flag. Input only the desired axes in any order. To annotate peaks, use the <code>--peaks</code> flag. This command processes only the acceleration data.</p> <p>For more information about the command, see CLI reference.</p> <p>Note</p> <p>FFT plot does not filter out the DC component of the signal.</p> Fast Fourier Transform (FFT) <p>Fast Fourier Transform (FFT) is an algorithm that computes the Discrete Fourier Transform (DFT). It's commonly used to analyze the frequency content of a signal. </p> <p>For vibration data, the FFT is measured in units of g. FFT amplitudes between data sets of different lengths (number of samples) are not directly comparable. This is due to FFT returning the absolute amplitude of frequency components, whose spectral widths are defined by the number of samples used to compute the FFT.</p>"},{"location":"specs/","title":"Specs","text":""},{"location":"specs/#sensor","title":"Sensor","text":"<ul> <li>Accelerometer ranges: \u00b12 g, \u00b14 g, \u00b18 g, \u00b116 g</li> <li>Gyro range: up to \u00b12000 dps</li> <li>Sample rate: 12.5 Hz to 4000 Hz</li> <li>Configurable low pass (second order) filter: 42 Hz to 3979 Hz</li> <li>IMU sensor: ICM-42688-P</li> </ul>"},{"location":"specs/#general","title":"General","text":"<ul> <li>Connectivity: USB 2.0 Full Speed 12 Mbps CDC via USB Type-C</li> <li>Power requirement: 5 V, 50 mA</li> <li>Cable length: 2.0 m</li> <li>Dimensions: \u230030 mm x 13 mm</li> </ul>"},{"location":"specs/#noise-performance","title":"Noise performance","text":"<ul> <li>Low noise configuration (500 Hz sample rate, 42 Hz filter, \u00b12 g range)<ul> <li>X axis noise: &lt; 0.5 mg RMS</li> <li>Y axis noise: &lt; 0.5 mg RMS</li> <li>Z axis noise: &lt; 1.2 mg RMS</li> </ul> </li> <li>Fastest sample rate, highest range (4 kHz sample rate, 2 kHz filter, \u00b116 g range)<ul> <li>X axis noise: &lt; 2.0 mg RMS</li> <li>Y axis noise: &lt; 2.5 mg RMS</li> <li>Z axis noise: &lt; 3.0 mg RMS</li> </ul> </li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#mounting","title":"Mounting","text":"<p>Mount PicoQuake to the object you want to measure as rigidly as possible. You can use the included releasable zip tie and zip tie adapter.</p> <p>For more demanding applications, it's recommended to design a custom 3D printed mount.</p> <p>Using double sided tape is fine, but it might dampen higher frequency vibrations.</p> <p>Axes orientation</p> <p>Orientation of the axes is marked on the device. Make note of it so you can later interpret the data correctly.</p> <p>Small objects</p> <p>Measuring vibrations of small objects, that are not much larger than the PicoQuake itself, can be challenging. The vibrations of the object will be dampened by the device itself.</p>"},{"location":"usage/#connection","title":"Connection","text":"<p>Connect PicoQuake to your computer's USB port. Multiple devices can be connected at the same time.</p> <p>When connected and receiving power, the green LED will light up. The orange LED will light up when data is being acquired.</p> <p>Short ID</p> <p>Each PicoQuake has a 4 character ID that is used to identify it. It's printed on the label. All commands that require device identification use this ID.</p>"},{"location":"usage/#commands","title":"Commands","text":"<p>PicoQuake is controlled using the command line interface (CLI).</p> <p>For detailed information on all the available commands run <code>picoquake --help</code> or browse the CLI reference.</p> <p>It's also possible to interface the device using the Python API. For more information, see the Python API reference.</p>"},{"location":"usage/#list-connected-devices","title":"List connected devices","text":"<p>List all connected PicoQuake devices with their Short ID and serial port.</p> <pre><code>picoquake list\n</code></pre>"},{"location":"usage/#live-display","title":"Live display","text":"<p>Display live data from a PicoQuake device. Useful for quick checks and debugging.</p> <pre><code>picoquake display &lt;short_id&gt;\n</code></pre>"},{"location":"usage/#data-acquisition","title":"Data acquisition","text":"<p>Acquire data from a PicoQuake device. The data is saved to a CSV file.</p> <pre><code>picoquake acquire &lt;short_id&gt; &lt;output_file&gt; [options]\n</code></pre> <p>For the description of the CSV file, see Acquisition CSV File.</p>"},{"location":"usage/#examples","title":"Examples","text":"<p>Acquire data for 10 seconds at 100 Hz sample rate. Filter set to 42 Hz. Save it to <code>data.csv</code>.</p> <pre><code>picoquake acquire c6e3 data.csv -s 10 -r 100 -f 42\n</code></pre> <p>Acquire data for 2 seconds at 4000 Hz sample rate. Filter set to 1000 Hz. Accelerometer range set to +-16 g, gyro range set to +-2000 dps. Save it to <code>data.csv</code>.</p> <pre><code>picoquake acquire c6e3 data.csv -s 2 -r 4000 -f 1000 -ar 16 -gr 2000\n</code></pre> <p>Warning</p> <p>Specified sampling rate, filter frequency, accelerometer range, and gyro range are not guaranteed. The actual values may differ due to hardware limitations and are rounded to the nearest supported value. The actual values are printed in the console output.</p> <p>Start prompt</p> <p>After pressing enter, you will be prompted to start the acquisition. This is done to be able to better control the start time. To skip the prompt, add the <code>-a</code> flag.</p> <p>Overwrite prompt</p> <p>If the CSV file already exists, you will be prompted to overwrite it. To skip the prompt, add the <code>-y</code> flag.</p>"},{"location":"usage/#trigger","title":"Trigger","text":"<p>Trigger data acquisition based on a threshold value.</p> <pre><code>picoquake trigger &lt;short_id&gt; &lt;output_file&gt; [options]\n</code></pre>"},{"location":"usage/#examples_1","title":"Examples","text":"<p>Trigger data acquisition when the RMS value of the acceleration in the X-axis exceeds 1 g. Save it to <code>data.csv</code>. Record for 1 second before and 5 seconds after the trigger.</p> <pre><code>picoquake trigger c6e3 data.csv  -r 1000 -f 303 --rms_threshold 1.0 --axis x --pre_seconds 1 --post_seconds 5\n</code></pre>"},{"location":"usage/#run","title":"Run","text":"<p>Run acquisition from a TOML configuration file. Supports advanced options like trigger and continuous acquisition.</p> <pre><code>picoquake run &lt;config_file&gt;\n</code></pre> <p>Example configuration file <code>config.toml</code>:</p> <pre><code>[device]\nshort_id = \"C6E3\" # short id of the device\n\n[config]\nsample_rate = 1000 # sample rate in Hz. Range 12.5 - 4000 Hz. Closest available selected.\nfilter = 100 # filter frequency in Hz. Range 42 - 3979 Hz. Closest available selected.\nacc_range = 16 # acceleration range in g. Range 2 - 16 g. Closest available selected.\ngyro_range = 1000 # gyro range in dps. Range 15.625 - 2000 dps. Closest available selected.\n\n[acquire]\n# define duration in seconds or number of samples\nseconds = 3\n# n_samples = 10000\n\n[output]\npath = \"pq_acq.csv\" # output file path or directory if use_timestamp is true\nconfirm_overwrite = true # require confirmation before overwriting\nsequential = true # add sequence number to filename\nuse_timestamp = false # use timestamp as filename\n</code></pre>"},{"location":"examples/bldc/","title":"BLDC Motor Vibrations","text":"<p>Brushless DC motors are a popular choice due to their longevity, efficiency and reasonably low cost. They can be a pretty significant source of vibration, however. </p> <p>The two main control algorithms for BLDCs are the basic 6-step trapezoidal BLDC commutation (tldr: turning windings on and off in the correct sequence) and sinusoidal FOC control (tldr: continuous sinusoidal phase currents instead of discrete steps). We wondered how the choice of the control method impacts the vibration produced by the motor.</p> <p>We carried out a simple comparison test by attaching PicoQuake to a small brushless outrunner motor being controlled by a VESC speed controller. In VESC configuration software, commutation method can be selected.</p> <p></p> <p>A one second recording was captured. Looking at the acceleration plots and RMS values, it is clear that FOC generates significantly less vibration. We can also look at the frequency distribution of vibration by generating a FFT plot. Trapezoidal control has a lot of the vibration power concentrated at one frequency, while FOC has multiple peaks of lower power.</p> <p></p> <p>As showcased in this example, PicoQuake can be used in BLDC drive applications to optimize for smooth and low noise operation, which can be particularly important in small electric mobility product such as electric bikes, scooters, etc.</p>"},{"location":"examples/trackpad/","title":"Trackpad Click","text":"<p>PicoQuake can be used to evaluate and optimize all the clicky things - such as the click of a trackpad on a laptop.</p> <p>Let\u2019s take a look at how a click of a traditional trackpad looks like. This one has a pivot point at the top and a tactile button under it at the bottom. PicoQuake was simply pressed lightly against the trackpad while clicking it. A recording was taken at the full 4 kHz sample rate. Trackpad\u2019s direction of travel is aligned with the Z axis of PicoQuake.</p> <p></p> <p>It\u2019s pretty clear what a click actually consists of. First, as the dome inside the tactile button below the trackpad collapses, it moves down quickly under the force applied. Because the travel is very short (around 0.2 mm), it bottoms out quickly, causing an acceleration jerk. This is the main part that feels like a click. After that, there is some ringing present due to flexibility in the system.</p> <p>During the release, the opposite happens. When the dome reaches the position at which it springs back, it pushes the trackpad up, causing an acceleration jerk. Quickly after, top position is reached and some ringing follows.</p> <p>More modern trackpads (such as in Apple MacBooks) work very differently however. Instead of a physical tactile button below the trackpad, a haptic actuator is used to shake the trackpad, emulating a click. It is triggered entirely by software, when sufficient pressing force is detected by a load cell.</p> <p></p> <p>Comparing the two with PicoQuake, we can see that the acceleration pattern is very similar regarding amplitude and duration. Which checks out, because the Magic Trackpad\u2019s click feels very much like a physical tactile button click.</p> <p>There is one important difference though - it vibrates in a different axis! Most of the movement is detected in the Y axis (front-back), not Z (up-down). It would appear that human fingers can\u2019t detect the direction of such short bursts of vibration very well. Therefore engineers picked the actuation direction that was the easiest to implement. This is confirmed by looking inside the MacBook. The magnetic actuator is clearly visible and indeed moves the trackpad in the front-back direction.</p>"},{"location":"python_api/data/","title":"Data","text":""},{"location":"python_api/data/#picoquake.data","title":"<code>data</code>","text":"<p>Data classes for storing device and acquisition data.</p>"},{"location":"python_api/data/#picoquake.data.AcquisitionData","title":"<code>AcquisitionData</code>  <code>dataclass</code>","text":"<p>Data class for storing the complete acquisition result, including IMU samples, device information, and acquisition configuration.</p> <p>Attributes:</p> <ul> <li> <code>samples</code>               (<code>list[IMUSample]</code>)           \u2013            <p>List of IMU samples.</p> </li> <li> <code>device</code>               (<code>DeviceInfo</code>)           \u2013            <p>Device information.</p> </li> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>Acquisition configuration.</p> </li> <li> <code>start_time</code>               (<code>datetime</code>)           \u2013            <p>Start time of the acquisition.</p> </li> <li> <code>skipped_samples</code>               (<code>int</code>)           \u2013            <p>Number of skipped samples due to acquisition issues.</p> </li> <li> <code>csv_path</code>               (<code>Optional[str]</code>)           \u2013            <p>Path to the CSV file containing the data. Used if the data was loaded from a file.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>Duration of the acquisition in seconds.</p> </li> <li> <code>num_samples</code>               (<code>int</code>)           \u2013            <p>Number of samples in the acquisition.</p> </li> <li> <code>integrity</code>               (<code>bool</code>)           \u2013            <p>Whether the acquisition has integrity (no skipped samples).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>to_csv</code>             \u2013              <p>Write the data to a CSV file.</p> </li> <li> <code>from_csv</code>             \u2013              <p>Load the data from a CSV file.</p> </li> </ul>"},{"location":"python_api/data/#picoquake.data.AcquisitionData.from_csv","title":"<code>from_csv(path)</code>  <code>classmethod</code>","text":"<p>Load the data from a CSV file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the CSV file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AcquisitionData</code> (              <code>AcquisitionData</code> )          \u2013            <p>Data loaded from the CSV file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an error occurs while parsing the CSV file.</p> </li> </ul>"},{"location":"python_api/data/#picoquake.data.AcquisitionData.re_centre","title":"<code>re_centre(index)</code>","text":"<p>Re-centre the data around a specific index.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>The index to re-centre the data around.</p> </li> </ul>"},{"location":"python_api/data/#picoquake.data.AcquisitionData.to_csv","title":"<code>to_csv(path)</code>","text":"<p>Write the data to a CSV file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>           \u2013            <p>Path to the CSV file.</p> </li> </ul>"},{"location":"python_api/data/#picoquake.data.ConfigEnum","title":"<code>ConfigEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Base class for configuration enums. Each member has two elements: an index and a parameter value. Parameter value can be either an integer or a float.</p> <p>Attributes:</p> <ul> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>Index of the member.</p> </li> <li> <code>param_value</code>               (<code>Union[float, int]</code>)           \u2013            <p>Parameter value of the member.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>from_index</code>             \u2013              <p>Return member with specified index.</p> </li> <li> <code>from_param_value</code>             \u2013              <p>Return member with specified parameter value.</p> </li> <li> <code>find_closest</code>             \u2013              <p>Return member with parameter value closest to specified value.</p> </li> </ul>"},{"location":"python_api/data/#picoquake.data.ConfigEnum.find_closest","title":"<code>find_closest(value)</code>  <code>classmethod</code>","text":"<p>Return member with parameter value closest to specified value.</p>"},{"location":"python_api/data/#picoquake.data.ConfigEnum.from_index","title":"<code>from_index(index)</code>  <code>classmethod</code>","text":"<p>Return member with specified index.</p>"},{"location":"python_api/data/#picoquake.data.ConfigEnum.from_param_value","title":"<code>from_param_value(value, tolerance=1e-05)</code>  <code>classmethod</code>","text":"<p>Return member with specified parameter value.</p>"},{"location":"python_api/data/#picoquake.data.IMUSample","title":"<code>IMUSample</code>  <code>dataclass</code>","text":"<p>Data class for storing a single IMU sample.</p> <p>Attributes:</p> <ul> <li> <code>count</code>               (<code>int</code>)           \u2013            <p>Sample count.</p> </li> <li> <code>acc_x</code>               (<code>float</code>)           \u2013            <p>Accelerometer X value.</p> </li> <li> <code>acc_y</code>               (<code>float</code>)           \u2013            <p>Accelerometer Y value.</p> </li> <li> <code>acc_z</code>               (<code>float</code>)           \u2013            <p>Accelerometer Z value.</p> </li> <li> <code>gyro_x</code>               (<code>float</code>)           \u2013            <p>Gyroscope X value.</p> </li> <li> <code>gyro_y</code>               (<code>float</code>)           \u2013            <p>Gyroscope Y value.</p> </li> <li> <code>gyro_z</code>               (<code>float</code>)           \u2013            <p>Gyroscope Z value.</p> </li> </ul>"},{"location":"python_api/examples/","title":"Examples","text":""},{"location":"python_api/examples/#acquire-data","title":"Acquire data","text":"<p>Sample rate is handled by the device and is very accurate. Use this method to acquire high quality data for further analysis.</p> <pre><code>import picoquake\n\nif __name__ == \"__main__\":\n    # Create a PicoQuake device\n    device = picoquake.PicoQuake(\"c6e3\")\n\n    # Configure acquisition\n    device.configure(\n        sample_rate=picoquake.SampleRate.hz_1000,\n        filter_hz=picoquake.Filter.hz_213,\n        acc_range=picoquake.AccRange.g_16,\n        gyro_range=picoquake.GyroRange.dps_2000,\n    )\n\n    # Alternatively, configure from float values.\n    # The closest available values will be used.\n    device.configure_approx(\n        sample_rate=1000,\n        filter_hz=200,\n        acc_range=16,\n        gyro_range=2000,\n    )\n\n    # Acquire data from the device\n    data, exception = device.acquire(seconds=1)\n\n    # Stop the device\n    device.stop()\n\n    # Check if an exception occurred\n    if exception is not None:\n        raise exception\n\n    # Print the acquired data\n    print(f\"Data: {data}\")\n\n    # Save to a CSV file\n    data.to_csv(\"acquisition.csv\")\n</code></pre>"},{"location":"python_api/examples/#read-continuously","title":"Read continuously","text":"<p>Sample rate is handled by this script and may not be accurate due to system load. Use this method to acquire data in real-time.</p> <pre><code>from time import sleep\n\nimport picoquake\n\nif __name__ == \"__main__\":\n    # Create a PicoQuake device\n    device = picoquake.PicoQuake(\"c6e3\")\n\n    # Configure acquisition\n    device.configure(\n        sample_rate=picoquake.SampleRate.hz_100,\n        filter_hz=picoquake.Filter.hz_42,\n        acc_range=picoquake.AccRange.g_16,\n        gyro_range=picoquake.GyroRange.dps_2000,\n    )\n\n    # Alternatively, configure from float values.\n    # The closest available values will be used.\n    device.configure_approx(\n        sample_rate=1000,\n        filter_hz=200,\n        acc_range=16,\n        gyro_range=2000,\n    )\n\n    # Start continuous acquisition\n    device.start_continuos()\n\n    # Read from device\n    try:\n        while True:\n            sample = device.read_last()\n            print(f\"Sample: {sample}\")\n            sleep(1)\n    except KeyboardInterrupt:\n        print(\"Stopped by user.\")\n    finally:\n        device.stop()\n</code></pre>"},{"location":"python_api/exceptions/","title":"Exceptions","text":""},{"location":"python_api/exceptions/#picoquake.exceptions","title":"<code>exceptions</code>","text":"<p>Exceptions used by the library.</p>"},{"location":"python_api/exceptions/#picoquake.exceptions.AcquisitionDataCorrupted","title":"<code>AcquisitionDataCorrupted</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when acquisition data is corrupted.</p>"},{"location":"python_api/exceptions/#picoquake.exceptions.AcquisitionIncomplete","title":"<code>AcquisitionIncomplete</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when acquisition is incomplete.</p>"},{"location":"python_api/exceptions/#picoquake.exceptions.ConnectionError","title":"<code>ConnectionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when connection to the device fails.</p>"},{"location":"python_api/exceptions/#picoquake.exceptions.DeviceError","title":"<code>DeviceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when connected device returns an error.</p> <p>Attributes:</p> <ul> <li> <code>error_code</code>               (<code>int</code>)           \u2013            <p>The error code returned by the device.</p> </li> </ul>"},{"location":"python_api/exceptions/#picoquake.exceptions.DeviceNotFound","title":"<code>DeviceNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when device with specified short ID is not found.</p>"},{"location":"python_api/exceptions/#picoquake.exceptions.HandshakeError","title":"<code>HandshakeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when handshake with the device fails.</p>"},{"location":"python_api/interface/","title":"Interface","text":""},{"location":"python_api/interface/#picoquake.interface","title":"<code>interface</code>","text":"<p>This module implements the main interface class for PicoQuake device.</p>"},{"location":"python_api/interface/#picoquake.interface.AcquisitionData","title":"<code>AcquisitionData</code>  <code>dataclass</code>","text":"<p>Data class for storing the complete acquisition result, including IMU samples, device information, and acquisition configuration.</p> <p>Attributes:</p> <ul> <li> <code>samples</code>               (<code>list[IMUSample]</code>)           \u2013            <p>List of IMU samples.</p> </li> <li> <code>device</code>               (<code>DeviceInfo</code>)           \u2013            <p>Device information.</p> </li> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>Acquisition configuration.</p> </li> <li> <code>start_time</code>               (<code>datetime</code>)           \u2013            <p>Start time of the acquisition.</p> </li> <li> <code>skipped_samples</code>               (<code>int</code>)           \u2013            <p>Number of skipped samples due to acquisition issues.</p> </li> <li> <code>csv_path</code>               (<code>Optional[str]</code>)           \u2013            <p>Path to the CSV file containing the data. Used if the data was loaded from a file.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>Duration of the acquisition in seconds.</p> </li> <li> <code>num_samples</code>               (<code>int</code>)           \u2013            <p>Number of samples in the acquisition.</p> </li> <li> <code>integrity</code>               (<code>bool</code>)           \u2013            <p>Whether the acquisition has integrity (no skipped samples).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>to_csv</code>             \u2013              <p>Write the data to a CSV file.</p> </li> <li> <code>from_csv</code>             \u2013              <p>Load the data from a CSV file.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.AcquisitionData.from_csv","title":"<code>from_csv(path)</code>  <code>classmethod</code>","text":"<p>Load the data from a CSV file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the CSV file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AcquisitionData</code> (              <code>AcquisitionData</code> )          \u2013            <p>Data loaded from the CSV file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an error occurs while parsing the CSV file.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.AcquisitionData.re_centre","title":"<code>re_centre(index)</code>","text":"<p>Re-centre the data around a specific index.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>The index to re-centre the data around.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.AcquisitionData.to_csv","title":"<code>to_csv(path)</code>","text":"<p>Write the data to a CSV file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>           \u2013            <p>Path to the CSV file.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.AcquisitionDataCorrupted","title":"<code>AcquisitionDataCorrupted</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when acquisition data is corrupted.</p>"},{"location":"python_api/interface/#picoquake.interface.AcquisitionIncomplete","title":"<code>AcquisitionIncomplete</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when acquisition is incomplete.</p>"},{"location":"python_api/interface/#picoquake.interface.ConfigEnum","title":"<code>ConfigEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Base class for configuration enums. Each member has two elements: an index and a parameter value. Parameter value can be either an integer or a float.</p> <p>Attributes:</p> <ul> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>Index of the member.</p> </li> <li> <code>param_value</code>               (<code>Union[float, int]</code>)           \u2013            <p>Parameter value of the member.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>from_index</code>             \u2013              <p>Return member with specified index.</p> </li> <li> <code>from_param_value</code>             \u2013              <p>Return member with specified parameter value.</p> </li> <li> <code>find_closest</code>             \u2013              <p>Return member with parameter value closest to specified value.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.ConfigEnum.find_closest","title":"<code>find_closest(value)</code>  <code>classmethod</code>","text":"<p>Return member with parameter value closest to specified value.</p>"},{"location":"python_api/interface/#picoquake.interface.ConfigEnum.from_index","title":"<code>from_index(index)</code>  <code>classmethod</code>","text":"<p>Return member with specified index.</p>"},{"location":"python_api/interface/#picoquake.interface.ConfigEnum.from_param_value","title":"<code>from_param_value(value, tolerance=1e-05)</code>  <code>classmethod</code>","text":"<p>Return member with specified parameter value.</p>"},{"location":"python_api/interface/#picoquake.interface.ConnectionError","title":"<code>ConnectionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when connection to the device fails.</p>"},{"location":"python_api/interface/#picoquake.interface.DeviceError","title":"<code>DeviceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when connected device returns an error.</p> <p>Attributes:</p> <ul> <li> <code>error_code</code>               (<code>int</code>)           \u2013            <p>The error code returned by the device.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.DeviceNotFound","title":"<code>DeviceNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when device with specified short ID is not found.</p>"},{"location":"python_api/interface/#picoquake.interface.HandshakeError","title":"<code>HandshakeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when handshake with the device fails.</p>"},{"location":"python_api/interface/#picoquake.interface.IMUSample","title":"<code>IMUSample</code>  <code>dataclass</code>","text":"<p>Data class for storing a single IMU sample.</p> <p>Attributes:</p> <ul> <li> <code>count</code>               (<code>int</code>)           \u2013            <p>Sample count.</p> </li> <li> <code>acc_x</code>               (<code>float</code>)           \u2013            <p>Accelerometer X value.</p> </li> <li> <code>acc_y</code>               (<code>float</code>)           \u2013            <p>Accelerometer Y value.</p> </li> <li> <code>acc_z</code>               (<code>float</code>)           \u2013            <p>Accelerometer Z value.</p> </li> <li> <code>gyro_x</code>               (<code>float</code>)           \u2013            <p>Gyroscope X value.</p> </li> <li> <code>gyro_y</code>               (<code>float</code>)           \u2013            <p>Gyroscope Y value.</p> </li> <li> <code>gyro_z</code>               (<code>float</code>)           \u2013            <p>Gyroscope Z value.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake","title":"<code>PicoQuake</code>","text":"<p>PicoQuake interface class</p> <p>Attributes:</p> <ul> <li> <code>device_info</code>               (<code>Optional[DeviceInfo]</code>)           \u2013            <p>The device information.</p> </li> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>The current configuration of the device.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>configure</code>             \u2013              <p>Configures the device with specified parameters.</p> </li> <li> <code>configure_approx</code>             \u2013              <p>Configures the device with approximated parameters.</p> </li> <li> <code>stop</code>             \u2013              <p>Stops the device.</p> </li> <li> <code>acquire</code>             \u2013              <p>Acquires data for a specified duration.</p> </li> <li> <code>start_continuos</code>             \u2013              <p>Starts the device in continuos mode.</p> </li> <li> <code>stop_continuos</code>             \u2013              <p>Stops the device in continuos mode.</p> </li> <li> <code>read</code>             \u2013              <p>Reads the specified number of samples received in continuos mode.</p> </li> <li> <code>read_last</code>             \u2013              <p>Reads the last sample received in continuos mode.</p> </li> <li> <code>trigger</code>             \u2013              <p>Triggers the device to start sampling when the RMS value exceeds the threshold.</p> </li> <li> <code>reboot_to_bootsel</code>             \u2013              <p>Reboots the device to BOOTSEL mode.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.config","title":"<code>config = Config(SampleRate.hz_100, Filter.hz_42, AccRange.g_4, GyroRange.dps_1000)</code>  <code>instance-attribute</code>","text":"<p>The current configuration of the device.</p>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.device_info","title":"<code>device_info = None</code>  <code>instance-attribute</code>","text":"<p>The device information.</p>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.__init__","title":"<code>__init__(short_id=None, port=None)</code>","text":"<p>Initializes the device.</p> <p>Specify <code>short_id</code> written on the device label to find the device automatically. Alternatively, specify the <code>port</code> to which the device is connected.</p> <p>Parameters:</p> <ul> <li> <code>short_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>A 4-character string used to identify the device. Written on the device label.</p> </li> <li> <code>port</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The port to which the device is connected.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If neither <code>short_id</code> nor <code>port</code> are provided, or if <code>short_id</code> is not a 4-character string.</p> </li> <li> <code>DeviceNotFound</code>             \u2013            <p>If device with <code>short_id</code> is not found.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.acquire","title":"<code>acquire(seconds=0, n_samples=0)</code>","text":"<p>Starts data acquisition of a specified duration. Duration can be specified in seconds or number of samples.</p> <p>Parameters:</p> <ul> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The duration of the acquisition in seconds.</p> </li> <li> <code>n_samples</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The number of samples to acquire.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[AcquisitionData, Optional[Exception]]</code>           \u2013            <p>A tuple containing the acquisition data and an exception if any occurred.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both <code>seconds</code> and <code>n_samples</code> are specified, if neither <code>seconds</code> nor <code>n_samples</code> are specified,         or if <code>seconds</code> or <code>n_samples</code> are negative.</p> </li> <li> <code>ConnectionError</code>             \u2013            <p>If the acquisition times out or if not all samples are received. Incomplete data is still saved.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.configure","title":"<code>configure(sample_rate, filter_hz, acc_range, gyro_range)</code>","text":"<p>Configures PicoQuake with acquisition parameters. Parameters are selected from enums with available values.</p> <p>Parameters:</p> <ul> <li> <code>sample_rate</code>               (<code>SampleRate</code>)           \u2013            <p>The sample rate in Hz.</p> </li> <li> <code>filter_hz</code>               (<code>Filter</code>)           \u2013            <p>The filter frequency in Hz.</p> </li> <li> <code>acc_range</code>               (<code>AccRange</code>)           \u2013            <p>The accelerometer range in g.</p> </li> <li> <code>gyro_range</code>               (<code>GyroRange</code>)           \u2013            <p>The gyroscope range in dps.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.configure_approx","title":"<code>configure_approx(sample_rate, filter_hz, acc_range, gyro_range)</code>","text":"<p>Configures PicoQuake with acquisition parameters. Parameters are approximated to the closest available values.</p> <p>Parameters:</p> <ul> <li> <code>sample_rate</code>               (<code>float</code>)           \u2013            <p>The sample rate in Hz.</p> </li> <li> <code>filter_hz</code>               (<code>float</code>)           \u2013            <p>The filter frequency in Hz.</p> </li> <li> <code>acc_range</code>               (<code>float</code>)           \u2013            <p>The accelerometer range in g.</p> </li> <li> <code>gyro_range</code>               (<code>float</code>)           \u2013            <p>The gyroscope range in dps.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.read","title":"<code>read(num=1, timeout=None)</code>","text":"<p>Reads the specified number of samples received in continuos mode. Samples are returned in the same order as they were received. If timeout is None, blocks until the specified number of samples are received.</p> <p>Parameters:</p> <ul> <li> <code>num</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of samples to read.</p> </li> <li> <code>timeout</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The maximum time to wait for the samples.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[IMUSample]</code>           \u2013            <p>List of samples. Might be less than <code>num</code> if timeout is set.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If continuos mode is not started.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.read_last","title":"<code>read_last(timeout=None)</code>","text":"<p>Reads the last sample received in continuos mode. If timeout is None, blocks until a sample is received.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The maximum time to wait for the sample.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[IMUSample]</code>           \u2013            <p>The latest sample received.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If continuos mode is not started.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.reboot_to_bootsel","title":"<code>reboot_to_bootsel()</code>","text":"<p>Reboots the device to BOOTSEL mode.</p>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.start_continuos","title":"<code>start_continuos()</code>","text":"<p>Starts the device in continuos mode. Samples can be read using <code>read_last()</code>.</p>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.stop","title":"<code>stop()</code>","text":"<p>Stops the device. Disconnects from the device and stops the acquisition.</p>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.stop_continuos","title":"<code>stop_continuos()</code>","text":"<p>Stops the device in continuos mode.</p>"},{"location":"python_api/interface/#picoquake.interface.PicoQuake.trigger","title":"<code>trigger(rms_threshold, pre_seconds, post_seconds, source='accel', axis='xyz', rms_window=1.0, on_trigger=None)</code>","text":"<p>Triggers the device to start sampling when the RMS value exceeds the threshold.</p> <p>Parameters:</p> <ul> <li> <code>rms_threshold</code>               (<code>float</code>)           \u2013            <p>The RMS threshold in g.</p> </li> <li> <code>pre_seconds</code>               (<code>float</code>)           \u2013            <p>The duration before the trigger in seconds.</p> </li> <li> <code>post_seconds</code>               (<code>float</code>)           \u2013            <p>The duration after the trigger in seconds.</p> </li> <li> <code>source</code>               (<code>str</code>, default:                   <code>'accel'</code> )           \u2013            <p>The source of the RMS value, either \"accel\" or \"gyro\".</p> </li> <li> <code>axis</code>               (<code>str</code>, default:                   <code>'xyz'</code> )           \u2013            <p>The axis or combination of axes to calculate the RMS value.</p> </li> <li> <code>rms_window</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The window length in seconds to calculate the RMS value.</p> </li> <li> <code>on_trigger</code>               (<code>Optional[Callable[[float], None]]</code>, default:                   <code>None</code> )           \u2013            <p>A callback function to call when the trigger is activated. The RMS value is passed as an argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[AcquisitionData, Optional[Exception]]</code>           \u2013            <p>A tuple containing the acquisition data and an exception if any occurred.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.deque_get_last_n","title":"<code>deque_get_last_n(data, n)</code>","text":"<p>Get the last n elements from a deque. Does not remove the elements from the deque.</p> <p>Args: data: Deque with data. n: Number of elements to get.</p> <p>Returns: List with the last n elements from the deque. If n is greater than the length of the deque, all elements are returned.</p>"},{"location":"python_api/interface/#picoquake.interface.deque_slice","title":"<code>deque_slice(dq, start, end=None)</code>","text":"<p>Return a slice from the deque. Behaves like the list slice method.</p> <p>Args: dq: The deque to slice. start: The starting index of the slice. end : The ending index of the slice.</p> <p>Returns: deque: A deque containing the specified slice.</p>"},{"location":"python_api/interface/#picoquake.interface.detrend","title":"<code>detrend(data)</code>","text":"<p>Remove the trend from a list of values.</p> <p>Args: data: List of values.</p> <p>Returns: List with the trend removed.</p>"},{"location":"python_api/interface/#picoquake.interface.get_unique_filename","title":"<code>get_unique_filename(path)</code>","text":"<p>Returns a unique filename by appending a sequential number if the file already exists.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the original file.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A unique filename.</p> </li> </ul>"},{"location":"python_api/interface/#picoquake.interface.imu_rms","title":"<code>imu_rms(samples, axes, de_trend=False)</code>","text":"<p>Calculate the root mean square of the acceleration and angular velocity components for the specified axes.</p> <p>Args: samples: List of IMU samples. axes: String with the axes to calculate the RMS values. Must be a combination of 'x', 'y', and 'z'. de_trend: If True, remove the trend from the data.</p> <p>Returns: Tuple of the root mean square of the acceleration and angular velocity.</p>"},{"location":"python_api/interface/#picoquake.interface.mean","title":"<code>mean(data)</code>","text":"<p>Calculate the mean of a list of values.</p> <p>Args: data: List of values.</p> <p>Returns: The mean of the values.</p>"},{"location":"python_api/interface/#picoquake.interface.rms","title":"<code>rms(data, de_trend=False)</code>","text":"<p>Calculate the root mean square of a list of values.</p> <p>data: List of values or a tuple of lists of values.        If a tuple is provided, the squares of the values in each list are summed. de_trend: If True, remove the trend from the data.</p> <p>Returns: The root mean square of the values.</p>"},{"location":"python_api/interface/#picoquake.interface.running_rms","title":"<code>running_rms(data, window_size, de_trend=False)</code>","text":"<p>Calculate the running root mean square of a list of values.</p> <p>Args: data: List of values. window_size: Size of the window for the running RMS calculation. de_trend: If True, remove the trend from the data.</p> <p>Returns: List with the running root mean square of the values.</p>"}]}